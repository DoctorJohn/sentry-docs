---
title: Logrus
description: "Logrus is a structured logger for Go, used to log messages in different formats and levels. This guide demonstrates how to integrate Logrus with Sentry to capture and send both logs and events to Sentry."
---

For a quick reference, there is a [complete example](https://github.com/getsentry/sentry-go/tree/master/_examples/logrus) at the Go SDK source code repository.

Go API documentation for the [`sentrylogrus` package](https://pkg.go.dev/github.com/getsentry/sentry-go/logrus) is also available.

## Requirements

Logrus structured logging is supported in Sentry Go SDK version `0.34.0` and above.

## Install

```bash
go get github.com/getsentry/sentry-go
go get github.com/getsentry/sentry-go/logrus
```

<Break />

## Configure

### Initialize the Sentry SDK

<PlatformContent includePath="getting-started-config" />

### Options

`sentrylogrus` provides two types of hooks to configure the integration with Sentry. Both hooks accept these options:
- **Levels**: A slice of `logrus.Level` specifying which log levels to capture
- **ClientOptions**: Standard `sentry.ClientOptions` for configuration

#### LogHook

Use `sentrylogrus.NewLogHook()` to send structured logs to Sentry. This hook captures log entries and sends them to Sentry's structured logging system.

```go
logHook, err := sentrylogrus.NewLogHook(
    []logrus.Level{logrus.InfoLevel, logrus.WarnLevel},
    sentry.ClientOptions{
        Dsn: "___PUBLIC_DSN___",
        EnableLogs: true, // Required for log entries
    })
```

#### EventHook

Use `sentrylogrus.NewEventHook()` to send log entries as Sentry events. This is useful for error tracking and alerting.

```go
eventHook, err := sentrylogrus.NewEventHook(
    []logrus.Level{logrus.ErrorLevel, logrus.FatalLevel, logrus.PanicLevel},
    sentry.ClientOptions{
        Dsn: "___PUBLIC_DSN___",
        Debug: true,
        AttachStacktrace: true,
    })
```

<Alert>
    When using both hooks, ensure you flush both of them before the application exits and register exit handlers for fatal logs to avoid losing pending events.
</Alert>

## Verify

```go
// Initialize Logrus
logger := logrus.New()
logger.Level = logrus.DebugLevel
logger.Out = os.Stderr

// Create event hook for errors
eventHook, err := sentrylogrus.NewEventHook([]logrus.Level{
	logrus.ErrorLevel,
	logrus.FatalLevel,
	logrus.PanicLevel,
}, sentry.ClientOptions{
	Dsn: "___PUBLIC_DSN___",
	AttachStacktrace: true,
})
if err != nil {
	panic(err)
}
defer eventHook.Flush(5 * time.Second)
logger.AddHook(eventHook)

// Test logging - this will be sent to Sentry as an event
logger.Error("This error will be sent to Sentry!")

// Example of logging with attributes
logger.WithField("user", "test-user").Error("An error occurred")
```

## Usage

To integrate Sentry with Logrus, you can set up both log hooks and event hooks to capture different types of data at various log levels.

```go
import (
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/sirupsen/logrus"
	"github.com/getsentry/sentry-go"
	sentrylogrus "github.com/getsentry/sentry-go/logrus"
)

func main() {
	// Initialize Logrus
	logger := logrus.New()

	// Log DEBUG and higher level logs to STDERR
	logger.Level = logrus.DebugLevel
	logger.Out = os.Stderr

	// send logs on InfoLevel
	logHook, err := sentrylogrus.NewLogHook(
		[]logrus.Level{logrus.InfoLevel},
		sentry.ClientOptions{
			Dsn: "___PUBLIC_DSN___",
			BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
				if hint.Context != nil {
					if req, ok := hint.Context.Value(sentry.RequestContextKey).(*http.Request); ok {
						// You have access to the original Request
						fmt.Println(req)
					}
				}
				fmt.Println(event)
				return event
			},
			// need to have logs enabled
			EnableLogs:       true,
			AttachStacktrace: true,
		})

	// send events on Error, Fatal, Panic levels
	eventHook, err := sentrylogrus.NewEventHook([]logrus.Level{
		logrus.ErrorLevel,
		logrus.FatalLevel,
		logrus.PanicLevel,
	}, sentry.ClientOptions{
		Dsn: "___PUBLIC_DSN___",
		BeforeSend: func(event *sentry.Event, hint *sentry.EventHint) *sentry.Event {
			if hint.Context != nil {
				if req, ok := hint.Context.Value(sentry.RequestContextKey).(*http.Request); ok {
					// You have access to the original Request
					fmt.Println(req)
				}
			}
			fmt.Println(event)
			return event
		},
		AttachStacktrace: true,
	})
	if err != nil {
		panic(err)
	}
	defer eventHook.Flush(5 * time.Second)
	defer logHook.Flush(5 * time.Second)
	logger.AddHook(eventHook)
	logger.AddHook(logHook)

	// Flushes before calling os.Exit(1) when using logger.Fatal
	// (else all defers are not called, and Sentry does not have time to send the event)
	logrus.RegisterExitHandler(func() {
		eventHook.Flush(5 * time.Second)
		logHook.Flush(5 * time.Second)
	})

    // Log a InfoLevel entry STDERR which is sent as a log to Sentry
    logger.Infof("Application has started")

    // Log an error to STDERR which is also sent to Sentry
    logger.Errorf("oh no!")

    // Log a fatal error to STDERR, which sends an event to Sentry and terminates the application
    logger.Fatalf("can't continue...")
	
    // Example of logging with attributes
	logger.WithField("user", "test-user").Error("An error occurred")
}
```

## Logs

For comprehensive logging setup with Logrus, including advanced configuration options and best practices, see the [Go Logs documentation](/platforms/go/logs/). The Logrus integration shown above provides seamless integration with Sentry's structured logging features.
